// <copyright file="Logarithmic.cs" company="CERN">
//   Copyright © 1999 CERN - European Organization for Nuclear Research.
//   Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
//   is hereby granted without fee, provided that the above copyright notice appear in all copies and 
//   that both that copyright notice and this permission notice appear in supporting documentationd 
//   CERN makes no representations about the suitability of this software for any purposed 
//   It is provided "as is" without expressed or implied warranty.
//   Ported from Java to C# by Kei Nakai, 2018.
// </copyright>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Runtime.CompilerServices;
using Cern.Jet.Math;
using Cern.Jet.Stat;
using Cern.Jet.Random.Engine;

namespace Cern.Jet.Random
{
    /// <summary>
    /// Logarithmic distribution.
    /// <p>
    /// Valid parameter ranges: <i>0 &lt; p &lt; 1</i>.
    /// <p>
    /// Instance methods operate on a user supplied uniform random number generator; they are unsynchronized.
    /// <dt>
    /// Static methods operate on a default uniform random number generator; they are synchronized.
    /// <p>
    /// <b>Implementation:</b> 
    /// <dt>
    /// Method: Inversion/Transformation.
    /// <dt>
    /// This is a port of <i>lsk.c</i> from the <A HREF="http://www.cis.tu-graz.ac.at/stat/stadl/random.html">C-RAND / WIN-RAND</A> library.
    /// C-RAND's implementation, in turn, is based upon
    /// <p>
    /// A.Wd Kemp (1981): Efficient generation of logarithmically distributed pseudo-random variables, Appld Statistd 30, 249-253.
    ///
    /// @author wolfgang.hoschek@cern.ch
    /// @version 1.0, 09/24/99
    /// </summary>
    public class Logarithmic : AbstractContinousDistribution
    {
        protected double my_p;

        // cached vars for method nextDouble(a)(for performance only)
        private double t, h, a_prev = -1.0;

        // The uniform random number generated shared by all <b>static</b> methodsd 
        protected static Logarithmic shared = new Logarithmic(0.5, MakeDefaultGenerator());

        /// <summary>
        /// Constructs a Logarithmic distribution.
        /// </summary>
        /// <param name="p"></param>
        /// <param name="randomGenerator"></param>
        public Logarithmic(double p, RandomEngine randomGenerator)
        {
            RandomGenerator = randomGenerator;
            SetState(p);
        }

        /// <summary>
        /// Returns a random number from the distribution.
        /// </summary>
        /// <returns></returns>
        public override double NextDouble()
        {
            return NextDouble(this.my_p);
        }

        /// <summary>
        /// Returns a random number from the distribution; bypasses the internal state.
        /// </summary>
        /// <param name="a"></param>
        /// <returns></returns>
        public double NextDouble(double a)
        {
            /******************************************************************
             *                                                                *
             *      Logarithmic Distribution - Inversion/Transformation       *
             *                                                                *
             ******************************************************************
             *                                                                *
             * The algorithm combines Inversion and Transformationd           *
             * It is based on the following fact: A random variable X from    *
             * the Logarithmic distribution has the property that X for fixed *
             * Y=y is Geometric distributed with P(X=x|Y=y)=(1-y)*y^(x-1)(*) *
             * where Y has distribution function F(y)=ln(1-y)/ln(1-p)d        *
             * So first random numbers y are generated by simple Inversion,   *
             * then k=(long int)(1+ln(u)/ln(y)) is a Geometric random number *
             * and because of (*) a Logarithmic oned                          *
             * To speed up the algorithm squeezes are used as well as the     *
             * fact, that many of the random numbers are 1 or 2 (depending on *
             * special circumstances)d                                        *
             * On an IBM/PC 486 optimal performance is achieved, if for p<.97 *
             * simple inversion is used and otherwise the transformationd     *
             * On an IBM/PC 286 inversion should be restricted to p<.90d      *
             *                                                                *
             ******************************************************************
             *                                                                *
             * FUNCTION:    - lsk  samples a random number from the           *
             *                Logarithmic distribution with                   *
             *                parameter  0 < p < 1 d                          *
             * REFERENCE:   - A.Wd Kemp (1981): Efficient generation of       *
             *                logarithmically distributed pseudo-random       *
             *                variables, Appld Statistd 30, 249-253d          *
             * SUBPROGRAMS: - drand(seed) ..d (0,1)-Uniform generator with    *
             *                unsigned long int *seedd                    *
             *                                                                *
             ******************************************************************/
            double u, v, p, q;
            int k;

            if (a != a_prev)
            {                   // Set-up
                a_prev = a;
                if (a < 0.97) t = -a / System.Math.Log(1.0 - a);
                else h = System.Math.Log(1.0 - a);
            }

            u = randomGenerator.Raw();
            if (a < 0.97)
            {                        // Inversion/Chop-down 
                k = 1;
                p = t;
                while (u > p)
                {
                    //Console.WriteLine("u="+u+", p="+p);
                    u -= p;
                    k++;
                    p *= a * (k - 1.0) / (double)k;
                }
                return k;
            }

            if (u > a) return 1;                 // Transformation
            u = randomGenerator.Raw();
            v = u;
            q = 1.0 - System.Math.Exp(v * h);
            if (u <= q * q)
            {
                k = (int)(1 + System.Math.Log(u) / System.Math.Log(q));
                return k;
            }
            if (u > q) return 1;
            return 2;
        }

        /// <summary>
        /// Sets the distribution parameter.
        /// </summary>
        /// <param name="p"></param>
        public void SetState(double p)
        {
            this.my_p = p;
        }

        /// <summary>
        /// Returns a random number from the distribution.
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.Synchronized)]
        public static double StaticNextDouble(double p)
        {
            return shared.NextDouble(p);
        }

        /// <summary>
        /// Returns a String representation of the receiver.
        /// </summary>
        /// <returns></returns>
        public override String ToString()
        {
            return this.GetType().Name + "(" + my_p + ")";
        }

        /// <summary>
        /// Sets the uniform random number generated shared by all <b>static</b> methods.
        /// </summary>
        /// <param name="randomGenerator">the new uniform random number generator to be shared.</param>
        [MethodImpl(MethodImplOptions.Synchronized)]
        private static void xStaticSetRandomGenerator(RandomEngine randomGenerator)
        {
            shared.RandomGenerator = randomGenerator;
        }
    }
}
